#include <types.h>
#include <kern/errno.h>
#include <lib.h>
#include <spinlock.h>
#include <vm.h>
#include "coremap.h"
static struct spinlock freemem_lock = SPINLOCK_INITIALIZER;
static unsigned char *freeRamFrames = NULL;
static unsigned long *allocSize = NULL;
static int nRamFrames = 0;
static int allocTableActive = 0;

int isTableActive () {
	int active;
	spinlock_acquire(&freemem_lock); 
	active = allocTableActive; 
	spinlock_release(&freemem_lock); 
	return active;
}

void update_table(paddr_t addr, int npages){
	spinlock_acquire(&freemem_lock); 
	allocSize[addr/PAGE_SIZE] = npages; 
	spinlock_release(&freemem_lock);
}

paddr_t getfreeppages(unsigned long npages){
	paddr_t addr;
	long first, found, i, np = (long) npages;

	if(!isTableActive()) return 0;

	spinlock_acquire(&freemem_lock);
	for(i=0, first=found=-1; i<nRamFrames; i++){
		if(freeRamFrames[i]){
			if(i==0 || !freeRamFrames[i-1])
				first = i;
			if(i-first+1 >= np){
				found = first;
				break;
			}
		}
	}
	if(found>=0){
		for (i=found;i<found+np;i++){
			freeRamFrames[i]=(unsigned char)0;
		}
		allocSize[found]=np;
		addr=(paddr_t)found*PAGE_SIZE;
		bzero((void)addr, PAGE_SIZE * npages);
	}
	else addr=0;
	spinlock_release(&freemem_lock);
	return addr;
}

int freeppages(paddr_t addr){
	long first, i, np = (long) addr/PAGE_SIZE;
	spinlock_acquire(&freemem_lock);
	first = addr / PAGE_SIZE;
	for(i=first; i<first+np; i++){
		freeRamFrames[i]=(unsigned char) 1;
	}
	spinlock_release(&freemem_lock);
	return 1;
}

void table_init(int nRamFrames){
	freeRamFrames = kmalloc(nRamFrames * sizeof(char));
	allocSize = kmalloc(nRamFrames * sizeof(long));
	if(freeRamFrames == NULL || allocSize == NULL) {
		freeRamFrames = NULL;
	 	allocSize = NULL;
		return;
	}
	int i;
	for(i=0; i<nRamFrames; i++) {
		freeRamFrames[i] = (unsigned char) 0;
		allocSize[i] = 0;
	}
	spinlock_acquire(&freemem_lock);
	allocTableActive = 1; 
	spinlock_release(&freemem_lock);
}
